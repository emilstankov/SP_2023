<img src="../img/logo_mk.png">


# Structural Programming
## Auditory Exercise 8 - Simple Algorithms for Working with Arrays
***

### 1. Reminder from Lectures
#### 1.1.1 Sorting 
#### 1.1.2 Bubble sort
The method starts with comparing the first element with its neighbour until we reach the last element. In each comparison, if the previous has larger value, then they swap their values. That way the largest element is moved to the last position in the array. This method is repeated from 1-st to the last but one element in the array, so this position will float the element that is largest but smaller than the last element in the array. At the and we compare only the 1-st and 2-nd element of the array.
#### 1.1.3 Selection sort 
We find the smallest element of the array and we swap the value of this element with the first element. After that, the first element is ignored (since its smallest) and recursively the method is repeated to rest of the array (second element, until the end). The recursion stops when there is only one element left. That is the final step, and the sorting is done.
#### 1.1.4 Insertion sort
With this method we sort by inserting each element in appropriate position, hence the name of the sort. After the first iteration, the second element a[1] is compared to the first element a[0]. After the second iteration the third element is compared with first and the second. In general, in each iteration the element is compared with all elements in front of it. If the comparison shows that the element should be inserted at some position, then we make space by shifting all elements one place in right. This procedure is repeated for each element in the array.

### 2. Exercises

### 2.2 Exercise 1
Write functions for sorting array by using the following methods for sorting:

-Bubble sort

-Selection sort

-Insertion sort

Write functions for reading and printing elements of an array, and write main program to test the sort functions.

```cpp
#include <iostream>

using namespace std;


//Reference vs. without reference
void swap(int& a, int& b) {
  int temp = a;
  a = b;
  b = temp;
}

void inputArray(int array[], int size)
{
    for (int i = 0; i < size; i++) {
        cout << "Enter element " << i + 1 << ": ";
        cin >> array[i];
    }
}

void printArray(int array[], int size)
{
    for (int i = 0; i < size; i++) {
        cout << array[i] << " ";
    }
    cout << endl;
}

void bubbleSort(int array[], int size)
 
{
    bool swapped = true;
    while (swapped) {
        swapped = false;
        for (int i = 0; i < size - 1; i++) {
            if (array[i] > array[i + 1]) {
                swap(array[i], array[i + 1]);
                swapped = true;
            }
        }
    }
}

void selectionSort(int array[], int size)
 
{
    for (int i = 0; i < size - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < size; j++) {
            if (array[j] < array[minIndex]) {
                minIndex = j;
            }
        }
        swap(array[i],array[minIndex]);
    }
}

void insertionSort(int array[], int size)
{
    for (int i = 1; i < size; i++) {
        int key = array[i];
        int j = i - 1;
        while (j >= 0 && array[j] > key) {
            array[j + 1] = array[j];
            j--;
        }
        array[j + 1] = key;
    }
}

int main()
 
{
    int size;
    cin >> size;

    int array[size];
    inputArray(array, size);
	//Original array
    printArray(array, size);

    bubbleSort(array, size);
	//Bubble sort
    printArray(array, size);

    selectionSort(array, size);
	//Selection sort
    printArray(array, size);

    insertionSort(array, size);
	//insertion sort
    printArray(array, size);

    return 0;
}
```

#### 2.2.1 Exercise 2

Write the following functions for searching an array:

-Linear search

-Binary search

Then write a program that fill an array with numbers from 1 to 1000000, and than generates random number in this range and finds its index by calling the two functions for searching.

#### 2.2.2. Homework:
For the functions count and compare the number of needed iterations to find the number.

```cpp
#include <iostream>
#include <cstdlib> // For rand()
#include <ctime> // For time()

using namespace std;

int linearSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return i;
        }
    }
    return -1;
}

int binarySearch(int arr[], int l, int r, int key)
 
{
    if (l <= r) {
        int mid = l + (r - l) / 2;

        if (arr[mid] == key) {
            return mid;
        } else
 
if (arr[mid] < key) {
            return binarySearch(arr, mid + 1, r, key);
        } else {
            return binarySearch(arr, l, mid - 1, key);
        }
    }
    return
 
-1;
}

int main()
 
{
    // Initialize the array with numbers from 1 to 1,000,000
    int arr[1000001];
    for (int i = 0; i < 1000001; i++) {
        arr[i] = i + 1;
    }

    // Generate a random number within the range
    srand(time(NULL)); // Seed the random number generator
    int randomNum = 1 + rand() % 1000000; // Generate a random number between 1 and 1,000,000

    // Perform linear search
    int linearSearchIndex = linearSearch(arr, 1000001, randomNum);
    cout << "Linear search: " << linearSearchIndex << endl;

    // Perform binary search
    int binarySearchIndex = binarySearch(arr, 0, 1000000, randomNum);
    cout << "Binary search: " << binarySearchIndex << endl;

    return 0;
}
```

#### 2.2. Exercise 3

Write a program that will transofrm the input array a into output array b in the following way:

$$b_i = a_i + a_{n-1-i}$$

The input array: 1 2 3 5 7

should be transformed into: 8 7 6 7 8


Explanation:
Since the input array a is of size n, that b will be the same size. The transformation is done by pairwise addition and replacement of the elements. For each pair of elements a[i] and a[n-1-i], where i is from [0 to n/2-1], the neighborhood sum is stored in b[i], while a[i] is replaced with [n-1-i]. If n is odd, the middle element a[n/2] is multiplied by 2.
```cpp
#include <iostream>

using namespace std;

#define MAX 100

void transform(int arr[], int n) {
    for (int i = 0, j = n - 1; i < j; i++, j--) {
        arr[i] += arr[j];
        arr[j] = arr[i];
    }

    if (n % 2) {
        arr[n / 2] *= 2;
    }
}

int main() {
    int n;
    int arr[MAX];

    cout << "Enter the size of the array: ";
    cin >> n;

    cout << "Enter the elements of the array: ";
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    transform(arr, n);

    cout << "Transformed array: ";
    for (int i = 0; i < n; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;

    return 0;
}
```

#### 2.3. Задача 4
The KMP algorithm, also known as the Knuth-Morris-Pratt algorithm, is an efficient string matching algorithm that precomputes a table of partial matches to improve efficiency.
This table, known as the partial match table (PMT), helps the algorithm quickly skip over characters that do not match in a text string.
The KMP algorithm has a time complexity of O(n + m), where n is the length of the text string and m is the length of the pattern being searched.
The following code demonstrates the usage of the KMP algorithm:
```
cpp
#include <iostream>

using namespace std;

int compute_partial_match_table(char pattern[], int m) {
    int table[m + 1];
    table[0] = 0;
    int i = 0;
    int j = 1;

    while (j < m) {
        if (pattern[i] == pattern[j]) {
            table[j] = i + 1;
            i++;
            j++;
        } else {
            if (i == 0) {
                table[j] = 0;
                j++;
            } else {
                i = table[i - 1];
            }
        }
    }

    return 0;
}

void kmp_string_matching(char text[], char pattern[], int n, int m) {
    int table[m + 1];
    compute_partial_match_table(pattern, m);

    int i = 0;
    int j = 0;
    int occurrences[n];
    int occurrences_count = 0;

    while (i < n) {
        if (text[i] == pattern[j]) {
            i++;
            j++;

            if (j == m) {
                occurrences[occurrences_count] = i - m;
                occurrences_count++;
                j = table[j - 1];
            }
        } else {
            if (j == 0) {
                i++;
            } else {
                j = table[j - 1];
            }
        }
    }

    cout << "Occurrences: ";
    for (int k = 0; k < occurrences_count; k++) {
        cout << occurrences[k] << " ";
    }
    cout << endl;
}

int main() {
    char text[] = "AABAACAADAABAABA";
    char pattern[] = "AABA";
    int n = strlen(text);
    int m = strlen(pattern);

    kmp_string_matching(text, pattern, n, m);

    return 0;
}
```